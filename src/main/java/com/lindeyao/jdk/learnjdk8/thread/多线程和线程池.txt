线程池概念：
顾名思义，就是将一堆线程放到一个池子里。使用线程执行任务的时候不需要创建，直接从池子里拿一个，
执行完之后不需要释放，直接放回池子里就可以了。这样的好处有：
1：线程可以复用
2：避免了线程创建和销毁的性能开销
3：线程的创建跟具体任务的执行是完全分开的


线程基础学习链接：https://blog.csdn.net/Evankaka/article/details/44153709

// 为了深入认识线程状态跟方法，自己引入 "主线程" 跟 "调用线程"，"竞争池" 跟 "等待队列" 四个概念
join():主线程会阻塞，直到调用线程(调用join方法的线程)执行完成，再执行主线程。从结果看：是将调用线程加入到主线程中，执行完调用线程之后才执行主线程。
sleep(long millis):主线程暂停多少毫秒，锁不会被释放，如果当时有多个线程，那么其他线程只能在竞争池中等待获取锁。
wait(),notify(),notifyall(): 这三个都是Object类的方法，而不是Thread类的方法。三个方法主要是为了同步多个线程对共享资源的操作，所以必须在持有
        锁的情况下，才能进行这三个操作。换句话说就是需要结合 synchronize 方法拿到锁对象，再对锁对象进行操作。
        wait():顾名思义就是等待，作用是将 执行锁对象wait方法的线程，进入到等待队列中，同时，主线程释放锁资源。
        notify():唤醒功能，将 等待队列中的某一个线程唤醒，进入到竞争池中，与池中的其他线程竞争锁资源。
        notifyall():唤醒等待队列中全部的线程到竞争池中，都去竞争锁资源。
        这三个方法，一般可以作用于生产者和消费者，对产品这个共享资源进行同步操作。具体可以看例子：WaitNotifyAndNotifyall，例子下方还有面试题